print("Start pruning " + pruning['pruning_method'])
if pruning['pruning_method'] == 'bb':
    bb_index= self._bb(y, predictions, X, pruning['pruning_cp'])
    print(bb_index)
    bagging_workflow = bagging_workflow[bb_index]
    predictions = bagging_workflow.predict(X) # Prunned Prediction
else :
    if pruning['pruning_method'] == 'mdsq':
        mdsq_index = self._mdsq(y, predictions, X, pruning['pruning_cp'])
        print(mdsq_index)
        bagging_workflow = bagging_workflow[mdsq_index]
        predictions = bagging_workflow.predict(X) # Prunned Prediction
# Avaliar Algoritmos

# IGNORE
#kfold = KFold(n_splits=4, random_state=0)
#cv_results = cross_val_score(bagging_workflow, X, y, cv=kfold, scoring=scoring)
#print(base_estimator," --> Score: %0.2f (+/-) %0.2f)" % (cv_results.mean(), cv_results.std() * 2))
#Rank[base_estimator] = cv_results.mean()
#print(params)
#Rank_Params[base_estimator] = params
#print(base_estimator, " --> Score: %0.3f)" % Rank[base_estimator])
                            



#
    # Prunning: Boosting-based pruning of models
    #
    def _bb(self,target, # Target names
                preds, # Predicts na training data
                data, # training data
                cutPoint): # ratio of the total n umber of models to cut off
        
        #targets = data[target]
        #print(preds.shape[0])
        prunedN = m.ceil((preds.shape[0] - (preds.shape[0] * cutPoint)))
        print("NumCol = ", preds.shape[0],"\nPrunedN = ", prunedN)
        preds = pd.DataFrame(preds)
        #print(preds)
        #print(prunedN)
        weights = []
        for i in range(data.shape[0]):
            weights.append(1/data.shape[0])
        #print(weights)
        
        ordem = {}
        for i in range(prunedN):
            print("i  =  ", i)
            k = 1
            errors = []
            for x in range(len(weights)):
                pred = np.asscalar(np.array(preds.iloc[x]))
                #print('target', target[x])
                erro = sum(
                        (
                          (
                            not
                            (pred == target[x])
                          )
                            * 1
                        )
                            * weights)
                #print('erro =', erro)
                errors.append(erro)
            #for x , y in zip(np.transpose(preds), target):
            #    errors.append(sum((not (x == targets.any())* 1) * weights))
            #    erro = sum(((not (x == target[y])) * 1) * weights)
            #    print('erro =', erro)
            #    errors.append(erro)
            
            ordem[i] = np.argmin(errors)

            for w in ordem.keys():
                errors[w] = max(errors) * 2


            errorU = min(errors)

            predU = []

            for x in range(len(weights)):
                #print(preds[ordem[i]])
                #print(target[x])
                predU.append(preds[ordem[i]] == target[x])
            
            k = k+1
            if errorU > 0.5:
                weights = []
                for i in range(data.shape[0]):
                    weights.append(1/data.shape[0])
            else:
                for w in range(len(weights)):
                    if predU[w].bool:
                        try:
                            weights[w] = weights[w] / (2*errorU)
                            break
                        except ZeroDivisionError:
                            weights[w] = 10.000e+300
                    else:
                        try:
                            weights[w] = weights[w] / (2*(1 - errorU))
                            break
                        except ZeroDivisionError:
                            weights[w] = 10.000e+300
        return ordem
    
    #
    # Prunning: Margin Distance Minimization
    #   
    def _mdsq(self,target, # Target names
                preds, # Predicts na training data
                data, # training data
                cutPoint): # ratio of the total n umber of models to cut off
        targets = data[target]
        
        prunedN = (preds.shape[1] - (preds.shape[1] * cutPoint))
        pred = [] # 1 ou -1 se acertar ou não
        ens = []
        o = []
        for i in range(data[targets].length):
            ens.append(0)
            o.append(0.075)

        for x, tg in zip(preds,data[targets]):
            if x == tg:
                pred.append(1)
            else:
                pred.append(-1)

        pred = pd.Dataframe(pred)
        
        ordem = []
        for i in range(1,prunedN):
            dist = []
            for x, y, z in zip(pred, ens, o):
                dist.append(m.sqrt(sum((((x + y) / i) - z)^2)))
            ens = ens + pred[min(dist)]
            pred = pd.Dataframe(pred[list(set(pred) - set(min(dist)))]) # Buscar o name em vez do valor, está mal.
            ordem[i] = min(dist) # Como inteiro, pelo nome
        return ordem   


